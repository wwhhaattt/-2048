<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modified 2048 Game</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #faf8ef;
        }
        #game-container {
            text-align: center;
        }
        #grid-container {
            display: grid;
            grid-template-columns: repeat(4, 100px);
            grid-template-rows: repeat(4, 100px);
            gap: 10px;
            background-color: #bbada0;
            padding: 10px;
            border-radius: 10px;
        }
        .cell {
            background-color: #cdc1b4;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            font-weight: bold;
            color: #776e65;
        }
        #score {
            font-size: 24px;
            margin-bottom: 10px;
        }
        #level {
            font-size: 24px;
            margin-bottom: 10px;
        }
        #message {
            font-size: 24px;
            margin-top: 10px;
            color: green;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="score">Score: 0</div>
        <div id="level">Level: 1 / Goal: 16</div>
        <div id="grid-container"></div>
        <div id="message"></div>
    </div>
    <script>
        const SIZE = 4;
        const grid = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
        let score = 0;
        let level = 1;
        const goals = Array.from({ length: 8 }, (_, i) => Math.pow(2, i + 4)); // 16,32,64,...,2048
        const gridContainer = document.getElementById('grid-container');
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');
        const messageElement = document.getElementById('message');

        function initGrid() {
            for (let i = 0; i < SIZE; i++) {
                for (let j = 0; j < SIZE; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `cell-${i}-${j}`;
                    gridContainer.appendChild(cell);
                }
            }
            addRandomTile();
            addRandomTile();
            updateGrid();
        }

        function addRandomTile() {
            const emptyCells = [];
            for (let i = 0; i < SIZE; i++) {
                for (let j = 0; j < SIZE; j++) {
                    if (grid[i][j] === 0) {
                        emptyCells.push({ row: i, col: j });
                    }
                }
            }
            if (emptyCells.length > 0) {
                const { row, col } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                grid[row][col] = Math.random() < 0.9 ? 2 : 4;
            }
        }

        function updateGrid() {
            for (let i = 0; i < SIZE; i++) {
                for (let j = 0; j < SIZE; j++) {
                    const cell = document.getElementById(`cell-${i}-${j}`);
                    cell.textContent = grid[i][j] !== 0 ? grid[i][j] : '';
                    cell.style.backgroundColor = getColor(grid[i][j]);
                }
            }
            scoreElement.textContent = `Score: ${score}`;
            levelElement.textContent = `Level: ${level} / Goal: ${goals[level - 1]}`;
        }

        function getColor(value) {
            const colors = {
                2: '#eee4da', 4: '#ede0c8', 8: '#f2b179', 16: '#f59563',
                32: '#f67c5f', 64: '#f65e3b', 128: '#edcf72', 256: '#edcc61',
                512: '#edc850', 1024: '#edc53f', 2048: '#edc22e'
            };
            return colors[value] || '#3c3a32';
        }

        function handleMove(direction) {
            let moved = false;
            const traverse = getTraverseOrder(direction);
            moved = mergeAndSlide(direction, traverse);
            if (moved) {
                checkLevelUp();
                addRandomTile();
                updateGrid();
                if (level > 8) {
                    messageElement.textContent = 'You Win!';
                }
            }
        }

        function getTraverseOrder(direction) {
            const rowTraverse = Array.from({ length: SIZE }, (_, i) => i);
            const colTraverse = Array.from({ length: SIZE }, (_, i) => i);
            if (direction === 'down') rowTraverse.reverse();
            if (direction === 'right') colTraverse.reverse();
            return { rowTraverse, colTraverse, isRow: direction === 'left' || direction === 'right' };
        }

        function mergeAndSlide(direction, { rowTraverse, colTraverse, isRow }) {
            let moved = false;
            const merged = new Set();

            // First, perform merges prioritizing farthest
            for (let i of rowTraverse) {
                for (let j of colTraverse) {
                    if (isRow) {
                        moved |= processLine(grid[i], direction === 'left' ? 'left' : 'right', merged, i);
                    } else {
                        const col = grid.map(row => row[j]);
                        moved |= processLine(col, direction === 'up' ? 'left' : 'right', merged, j); // Pass column index or something, but since merged is value-pos, need adjustment
                        // For columns, pos is row
                        // Write back
                        for (let k = 0; k < SIZE; k++) {
                            grid[k][j] = col[k];
                        }
                    }
                }
            }

            // Then, slide to fill gaps
            for (let i = 0; i < SIZE; i++) {
                for (let j = 0; j < SIZE; j++) {
                    if (isRow) {
                        moved |= slideLine(grid[i], direction === 'left' ? 'left' : 'right');
                    } else {
                        const col = grid.map(row => row[j]);
                        moved |= slideLine(col, direction === 'up' ? 'left' : 'right');
                        for (let k = 0; k < SIZE; k++) {
                            grid[k][j] = col[k];
                        }
                    }
                }
            }
            return moved;
        }

        function processLine(line, dir, merged, lineIndex) {
            let changed = false;
            const posKey = (val, pos) => `${lineIndex}-${val}-${pos}`; // Make unique per line
            let pos = dir === 'left' ? SIZE - 2 : 1;
            const step = dir === 'left' ? -1 : 1;
            const maxPos = dir === 'left' ? 0 : SIZE - 2;

            while ((dir === 'left' ? pos >= 0 : pos <= SIZE - 1)) {
                let a = pos;
                let b = pos + (dir === 'left' ? 1 : -1);
                if (a >= 0 && a < SIZE && b >= 0 && b < SIZE && line[a] !== 0 && line[b] !== 0 && line[a] !== line[b] && !merged.has(posKey(line[a], a)) && !merged.has(posKey(line[b], b))) {
                    line[b] += line[a];
                    line[a] = 0;
                    score += line[b];
                    merged.add(posKey(line[b], b));
                    changed = true;
                }
                pos += step;
                if (dir === 'left' ? pos < 0 : pos > SIZE - 1) break;
            }
            return changed;
        }

        function slideLine(line, dir) {
            const oldLine = [...line];
            let newLine = line.filter(val => val !== 0);
            if (dir === 'right' || dir === 'down') {
                while (newLine.length < SIZE) newLine.unshift(0);
            } else {
                while (newLine.length < SIZE) newLine.push(0);
            }
            for (let i = 0; i < SIZE; i++) {
                line[i] = newLine[i];
            }
            return oldLine.join(',') !== line.join(',');
        }

        function checkLevelUp() {
            const goal = goals[level - 1];
            let hasGoal = false;
            for (let i = 0; i < SIZE; i++) {
                for (let j = 0; j < SIZE; j++) {
                    if (grid[i][j] === goal) {
                        hasGoal = true;
                    }
                    if (grid[i][j] >= goal) {
                        grid[i][j] = 0;
                    }
                }
            }
            if (hasGoal) {
                level++;
                messageElement.textContent = `Level ${level - 1} Completed!`;
                setTimeout(() => { messageElement.textContent = ''; }, 2000);
            }
        }

        document.addEventListener('keydown', (e) => {
            const directions = {
                ArrowUp: 'up', ArrowDown: 'down', ArrowLeft: 'left', ArrowRight: 'right',
                w: 'up', W: 'up', s: 'down', S: 'down', a: 'left', A: 'left', d: 'right', D: 'right'
            };
            if (directions[e.key]) {
                handleMove(directions[e.key]);
            }
        });

        initGrid();
    </script>
</body>
</html>