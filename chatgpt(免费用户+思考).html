<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>不同合并 2048 - 关卡版</title>
<style>
  :root{--bg:#faf8ef;--card:#bbada0;--empty:#cdc1b4;--tile-size:90px}
  *{box-sizing:border-box;font-family:system-ui,Segoe UI,Roboto,'PingFang SC','Hiragino Sans GB',sans-serif}
  body{margin:0;background:var(--bg);display:flex;align-items:center;justify-content:center;height:100vh}
  .container{width:420px;padding:20px;background:#fff;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,0.15)}
  h1{margin:0 0 10px;font-size:20px}
  .top{display:flex;justify-content:space-between;align-items:center}
  .info{display:flex;gap:10px}
  .panel{background:#f6f4ef;padding:8px 12px;border-radius:8px;text-align:center}
  .grid{width:100%;height:calc(var(--tile-size)*4 + 24px);background:var(--card);padding:12px;border-radius:8px;display:grid;grid-template-columns:repeat(4,1fr);grid-gap:12px}
  .cell{width:100%;height:var(--tile-size);border-radius:6px;background:var(--empty);display:flex;align-items:center;justify-content:center;font-weight:700;font-size:20px;color:#776e65}
  .tile{position:relative}
  .controls{margin-top:12px;display:flex;gap:8px;justify-content:space-between}
  button{padding:8px 12px;border-radius:8px;border:0;background:#8f7a66;color:#fff;font-weight:700;cursor:pointer}
  .small{font-size:12px;padding:6px 8px}
  .message{margin-top:12px;padding:10px;border-radius:8px;background:#eef9ff;color:#044b5b}
  .hidden{display:none}
  .footer{margin-top:10px;font-size:12px;color:#666}
  /* tile colors (simple) */
  .val-0{background:transparent}
  .val-2{background:#eee4da}
  .val-4{background:#ede0c8}
  .val-other{background:#f2b179;color:#fff}
</style>
</head>
<body>
  <div class="container">
    <div class="top">
      <h1>不同合并 关卡版</h1>
      <div class="info">
        <div class="panel">关卡 <span id="level">1</span>/8</div>
        <div class="panel">目标 <span id="target">16</span></div>
      </div>
    </div>

    <div class="grid" id="grid"></div>

    <div class="controls">
      <div style="display:flex;gap:8px">
        <button id="btn-up">↑</button>
        <button id="btn-left">←</button>
        <button id="btn-down">↓</button>
        <button id="btn-right">→</button>
      </div>
      <div style="display:flex;gap:8px">
        <button id="btn-restart" class="small">重开</button>
        <button id="btn-undo" class="small">撤销</button>
      </div>
    </div>

    <div id="message" class="message hidden"></div>
    <div class="footer">说明：只有不同的数可以合并。每次滑动优先合并朝向边缘最远的相邻不同数字，合成后的格子本次移动内不能再次合并。合成目标后会清除所有大于等于目标的数字，并进入下一关。</div>
  </div>

<script>
(() => {
  const SIZE = 4;
  const MAX_LEVEL = 8;
  let board = [];
  let level = 1;
  let target = Math.pow(2, level + 3);
  let movedThisTurn = false;
  let prevState = null; // for simple undo (one step)

  const gridEl = document.getElementById('grid');
  const levelEl = document.getElementById('level');
  const targetEl = document.getElementById('target');
  const msgEl = document.getElementById('message');

  function initBoard() {
    board = Array.from({length: SIZE}, () => Array(SIZE).fill(0));
    spawnRandom(); spawnRandom();
    render();
  }

  function saveState() {
    prevState = {board:board.map(r=>r.slice()), level, target};
  }
  function undo() {
    if (!prevState) return;
    board = prevState.board.map(r=>r.slice());
    level = prevState.level; target = prevState.target;
    prevState = null; updateUI(); render();
  }

  function spawnRandom() {
    const empties = [];
    for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (!board[r][c]) empties.push([r,c]);
    if (!empties.length) return false;
    const [r,c] = empties[Math.floor(Math.random()*empties.length)];
    board[r][c] = Math.random()<0.9?2:4;
    return true;
  }

  function render(){
    gridEl.innerHTML = '';
    for (let r=0;r<SIZE;r++){
      for (let c=0;c<SIZE;c++){
        const v = board[r][c];
        const div = document.createElement('div');
        div.className = 'cell tile ' + (v===0? 'val-0' : (v===2?'val-2': v===4?'val-4':'val-other'));
        div.textContent = v===0? '': v;
        gridEl.appendChild(div);
      }
    }
    updateUI();
  }

  function updateUI(){
    levelEl.textContent = level;
    targetEl.textContent = target;
  }

  // process a single line array according to the special merge rules
  function processLine(arr, dir) {
    // arr: array of numbers from left-to-right (or top-to-bottom)
    // dir: 'left' or 'right' - determines which side is "edge" to favor
    // We'll operate on objects to track merged flags
    let items = arr.map(v=>({v, merged:false}));

    function compress(){
      items = items.filter(it=>it.v!==0);
    }
    compress();

    while (true) {
      // find the farthest adjacent pair toward the edge
      let idx = -1;
      if (dir==='right'){
        for (let i=items.length-2;i>=0;i--) {
          if (items[i].v!==0 && items[i+1] && items[i+1].v!==0 && items[i].v!==items[i+1].v && !items[i].merged && !items[i+1].merged){ idx = i; break; }
        }
      } else {
        for (let i=0;i<items.length-1;i++){
          if (items[i].v!==0 && items[i+1].v!==0 && items[i].v!==items[i+1].v && !items[i].merged && !items[i+1].merged){ idx = i; break; }
        }
      }
      if (idx===-1) break;
      // merge items[idx] into items[idx+1] (for 'right') or into items[idx] (for 'left') depending on direction
      if (dir==='right'){
        items[idx+1].v = items[idx].v + items[idx+1].v;
        items[idx+1].merged = true;
        items.splice(idx,1);
      } else {
        items[idx].v = items[idx].v + items[idx+1].v;
        items[idx].merged = true;
        items.splice(idx+1,1);
      }
    }

    // after all merges, compress and pad zeros to make length SIZE
    compress();
    const out = [];
    if (dir==='right'){
      const pad = Array(SIZE - items.length).fill(0).map(()=>({v:0}));
      const final = pad.concat(items);
      for (let it of final) out.push(it.v);
    } else {
      const pad = Array(SIZE - items.length).fill(0).map(()=>({v:0}));
      const final = items.concat(pad);
      for (let it of final) out.push(it.v);
    }
    return out;
  }

  function move(direction){
    // direction: 'left','right','up','down'
    saveState();
    let moved = false;
    if (direction==='left' || direction==='right'){
      for (let r=0;r<SIZE;r++){
        const row = board[r].slice();
        const processed = processLine(row, direction==='right'? 'right':'left');
        for (let c=0;c<SIZE;c++){
          if (board[r][c] !== processed[c]) moved = true;
          board[r][c] = processed[c];
        }
      }
    } else {
      for (let c=0;c<SIZE;c++){
        const col = [];
        for (let r=0;r<SIZE;r++) col.push(board[r][c]);
        const processed = processLine(col, direction==='down'? 'right':'left');
        for (let r=0;r<SIZE;r++){
          if (board[r][c] !== processed[r]) moved = true;
          board[r][c] = processed[r];
        }
      }
    }

    if (moved){
      spawnRandom();
      render();
      checkLevelProgress();
      if (isGameOver()) showMessage('已无可移动的格子，游戏结束', true);
    }
  }

  function checkLevelProgress(){
    // If any tile equals target, then clear all tiles >= target, advance level
    let hit = false;
    for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (board[r][c] === target) hit = true;
    if (hit) {
      // clear all >= target
      for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (board[r][c] >= target) board[r][c] = 0;
      level++;
      if (level>MAX_LEVEL) {
        render();
        showMessage('恭喜！已通过所有关卡，胜利！', true);
        return;
      }
      target = Math.pow(2, level + 3);
      showMessage('通过关卡！进入第'+level+'关，目标 '+target, false);
      render();
    }
  }

  function showMessage(text, persist){
    msgEl.textContent = text;
    msgEl.classList.remove('hidden');
    if (!persist) setTimeout(()=> msgEl.classList.add('hidden'), 2500);
  }

  function isGameOver(){
    // if any empty, not over
    for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (!board[r][c]) return false;
    // check if any legal merges exist (adjacent different numbers)
    for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE-1;c++) if (board[r][c] !== board[r][c+1]) return false;
    for (let c=0;c<SIZE;c++) for (let r=0;r<SIZE-1;r++) if (board[r][c] !== board[r+1][c]) return false;
    return true;
  }

  // keyboard
  window.addEventListener('keydown', e=>{
    if (e.key==='ArrowLeft' || e.key==='a' || e.key==='A') move('left');
    if (e.key==='ArrowRight' || e.key==='d' || e.key==='D') move('right');
    if (e.key==='ArrowUp' || e.key==='w' || e.key==='W') move('up');
    if (e.key==='ArrowDown' || e.key==='s' || e.key==='S') move('down');
  });

  // buttons
  document.getElementById('btn-left').addEventListener('click', ()=>move('left'));
  document.getElementById('btn-right').addEventListener('click', ()=>move('right'));
  document.getElementById('btn-up').addEventListener('click', ()=>move('up'));
  document.getElementById('btn-down').addEventListener('click', ()=>move('down'));
  document.getElementById('btn-restart').addEventListener('click', ()=>{ level=1; target=Math.pow(2,level+3); saveState(); initBoard(); });
  document.getElementById('btn-undo').addEventListener('click', undo);

  // simple touch swipe
  let touchStart = null;
  window.addEventListener('touchstart', e=>{ const t=e.touches[0]; touchStart={x:t.clientX,y:t.clientY}; });
  window.addEventListener('touchend', e=>{
    if (!touchStart) return;
    const t = (e.changedTouches && e.changedTouches[0]) || touchStart;
    const dx = t.clientX - touchStart.x;
    const dy = t.clientY - touchStart.y;
    if (Math.abs(dx) > Math.abs(dy)){
      if (dx>30) move('right'); else if (dx < -30) move('left');
    } else {
      if (dy>30) move('down'); else if (dy < -30) move('up');
    }
    touchStart = null;
  });

  // start
  initBoard();
  updateUI();
})();
</script>
</body>
</html>
